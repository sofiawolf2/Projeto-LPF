{"version":3,"file":"tetste.js","sources":["src/kotlin/collections/Collections.kt","src/kotlin/util/Preconditions.kt","common/src/generated/_Ranges.kt","../../../../../src/main/kotlin/main.kt"],"sourcesContent":["/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n@file:OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\nimport kotlin.random.Random\n\ninternal object EmptyIterator : ListIterator<Nothing> {\n    override fun hasNext(): Boolean = false\n    override fun hasPrevious(): Boolean = false\n    override fun nextIndex(): Int = 0\n    override fun previousIndex(): Int = -1\n    override fun next(): Nothing = throw NoSuchElementException()\n    override fun previous(): Nothing = throw NoSuchElementException()\n}\n\ninternal object EmptyList : List<Nothing>, Serializable, RandomAccess {\n    private const val serialVersionUID: Long = -7390468764508069838L\n\n    override fun equals(other: Any?): Boolean = other is List<*> && other.isEmpty()\n    override fun hashCode(): Int = 1\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun get(index: Int): Nothing = throw IndexOutOfBoundsException(\"Empty list doesn't contain element at index $index.\")\n    override fun indexOf(element: Nothing): Int = -1\n    override fun lastIndexOf(element: Nothing): Int = -1\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun listIterator(): ListIterator<Nothing> = EmptyIterator\n    override fun listIterator(index: Int): ListIterator<Nothing> {\n        if (index != 0) throw IndexOutOfBoundsException(\"Index: $index\")\n        return EmptyIterator\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<Nothing> {\n        if (fromIndex == 0 && toIndex == 0) return this\n        throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex\")\n    }\n\n    private fun readResolve(): Any = EmptyList\n}\n\ninternal fun <T> Array<out T>.asCollection(): Collection<T> = ArrayAsCollection(this, isVarargs = false)\n\nprivate class ArrayAsCollection<T>(val values: Array<out T>, val isVarargs: Boolean) : Collection<T> {\n    override val size: Int get() = values.size\n    override fun isEmpty(): Boolean = values.isEmpty()\n    override fun contains(element: T): Boolean = values.contains(element)\n    override fun containsAll(elements: Collection<T>): Boolean = elements.all { contains(it) }\n    override fun iterator(): Iterator<T> = values.iterator()\n    // override hidden toArray implementation to prevent copying of values array\n    public fun toArray(): Array<out Any?> = values.copyToArrayOfAny(isVarargs)\n}\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\npublic fun <T> emptyList(): List<T> = EmptyList\n\n/**\n * Returns a new read-only list of given elements.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.readOnlyList\n */\npublic fun <T> listOf(vararg elements: T): List<T> = if (elements.size > 0) elements.asList() else emptyList()\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> listOf(): List<T> = emptyList()\n\n/**\n * Returns an empty new [MutableList].\n * @sample samples.collections.Collections.Lists.emptyMutableList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableListOf(): MutableList<T> = ArrayList()\n\n/**\n * Returns an empty new [ArrayList].\n * @sample samples.collections.Collections.Lists.emptyArrayList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> arrayListOf(): ArrayList<T> = ArrayList()\n\n/**\n * Returns a new [MutableList] with the given elements.\n * @sample samples.collections.Collections.Lists.mutableList\n */\npublic fun <T> mutableListOf(vararg elements: T): MutableList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new [ArrayList] with the given elements.\n * @sample samples.collections.Collections.Lists.arrayList\n */\npublic fun <T> arrayListOf(vararg elements: T): ArrayList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new read-only list either of single given element, if it is not null, or empty list if the element is null. The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(element: T?): List<T> = if (element != null) listOf(element) else emptyList()\n\n/**\n * Returns a new read-only list only of those given elements, that are not null.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(vararg elements: T?): List<T> = elements.filterNotNull()\n\n/**\n * Creates a new read-only list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.readOnlyListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> List(size: Int, init: (index: Int) -> T): List<T> = MutableList(size, init)\n\n/**\n * Creates a new mutable list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.mutableListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList(size: Int, init: (index: Int) -> T): MutableList<T> {\n    val list = ArrayList<T>(size)\n    repeat(size) { index -> list.add(init(index)) }\n    return list\n}\n\n/**\n * Builds a new read-only [List] by populating a [MutableList] using the given [builderAction]\n * and returning a read-only list with the same elements.\n *\n * The list passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * @sample samples.collections.Builders.Lists.buildListSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildList(@BuilderInference builderAction: MutableList<E>.() -> Unit): List<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildListInternal(builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildListInternal(builderAction: MutableList<E>.() -> Unit): List<E>\n\n/**\n * Builds a new read-only [List] by populating a [MutableList] using the given [builderAction]\n * and returning a read-only list with the same elements.\n *\n * The list passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * [capacity] is used to hint the expected number of elements added in the [builderAction].\n *\n * @throws IllegalArgumentException if the given [capacity] is negative.\n *\n * @sample samples.collections.Builders.Lists.buildListSampleWithCapacity\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildList(capacity: Int, @BuilderInference builderAction: MutableList<E>.() -> Unit): List<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildListInternal(capacity, builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildListInternal(capacity: Int, builderAction: MutableList<E>.() -> Unit): List<E>\n\n/**\n * Returns an [IntRange] of the valid indices for this collection.\n * @sample samples.collections.Collections.Collections.indicesOfCollection\n */\npublic val Collection<*>.indices: IntRange\n    get() = 0..size - 1\n\n/**\n * Returns the index of the last item in the list or -1 if the list is empty.\n *\n * @sample samples.collections.Collections.Lists.lastIndexOfList\n */\npublic val <T> List<T>.lastIndex: Int\n    get() = this.size - 1\n\n/**\n * Returns `true` if the collection is not empty.\n * @sample samples.collections.Collections.Collections.collectionIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable collection is either null or empty.\n * @sample samples.collections.Collections.Collections.collectionIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.isEmpty()\n}\n\n/**\n * Returns this Collection if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Collections.collectionOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.orEmpty(): Collection<T> = this ?: emptyList()\n\n/**\n * Returns this List if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Lists.listOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>?.orEmpty(): List<T> = this ?: emptyList()\n\n/**\n * Returns this collection if it's not empty\n * or the result of calling [defaultValue] function if the collection is empty.\n *\n * @sample samples.collections.Collections.Collections.collectionIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : Collection<*>, C : R =\n    if (isEmpty()) defaultValue() else this\n\n\n/**\n * Checks if all elements in the specified collection are contained in this collection.\n *\n * Allows to overcome type-safety restriction of `containsAll` that requires to pass a collection of type `Collection<E>`.\n * @sample samples.collections.Collections.Collections.collectionContainsAll\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> Collection<T>.containsAll(elements: Collection<T>): Boolean = this.containsAll(elements)\n\n\n/**\n * Returns a new list with the elements of this list randomly shuffled\n * using the specified [random] instance as the source of randomness.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Iterable<T>.shuffled(random: Random): List<T> = toMutableList().apply { shuffle(random) }\n\n\ninternal fun <T> List<T>.optimizeReadOnlyList() = when (size) {\n    0 -> emptyList()\n    1 -> listOf(this[0])\n    else -> this\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of its elements,\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchOnComparable\n * @sample samples.collections.Collections.Lists.binarySearchWithBoundaries\n */\npublic fun <T : Comparable<T>> List<T?>.binarySearch(element: T?, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = compareValues(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the specified [comparator],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted according to the specified [comparator].\n * @sample samples.collections.Collections.Lists.binarySearchWithComparator\n */\npublic fun <T> List<T>.binarySearch(element: T, comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparator.compare(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for an element having the key returned by the specified [selector] function\n * equal to the provided [key] value using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of keys of its elements.\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements with the specified [key], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element with the specified [key], if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchByKey\n */\npublic inline fun <T, K : Comparable<K>> List<T>.binarySearchBy(\n    key: K?,\n    fromIndex: Int = 0,\n    toIndex: Int = size,\n    crossinline selector: (T) -> K?\n): Int =\n    binarySearch(fromIndex, toIndex) { compareValues(selector(it), key) }\n\n// do not introduce this overload --- too rare\n//public fun <T, K> List<T>.binarySearchBy(key: K, comparator: Comparator<K>, fromIndex: Int = 0, toIndex: Int = size(), selector: (T) -> K): Int =\n//        binarySearch(fromIndex, toIndex) { comparator.compare(selector(it), key) }\n\n\n/**\n * Searches this list or its range for an element for which the given [comparison] function returns zero using the binary search algorithm.\n *\n * The list is expected to be sorted so that the signs of the [comparison] function's return values ascend on the list elements,\n * i.e. negative values come before zero and zeroes come before positive values.\n * Otherwise, the result is undefined.\n *\n * If the list contains multiple elements for which [comparison] returns zero, there is no guarantee which one will be found.\n *\n * @param comparison function that returns zero when called on the list element being searched.\n * On the elements coming before the target element, the function must return negative values;\n * on the elements coming after the target element, the function must return positive values.\n *\n * @return the index of the found element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchWithComparisonFunction\n */\npublic fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, comparison: (T) -> Int): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparison(midVal)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Checks that `from` and `to` are in\n * the range of [0..size] and throws an appropriate exception, if they aren't.\n */\nprivate fun rangeCheck(size: Int, fromIndex: Int, toIndex: Int) {\n    when {\n        fromIndex > toIndex -> throw IllegalArgumentException(\"fromIndex ($fromIndex) is greater than toIndex ($toIndex).\")\n        fromIndex < 0 -> throw IndexOutOfBoundsException(\"fromIndex ($fromIndex) is less than zero.\")\n        toIndex > size -> throw IndexOutOfBoundsException(\"toIndex ($toIndex) is greater than size ($size).\")\n    }\n}\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkIndexOverflow(index: Int): Int\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkCountOverflow(count: Int): Int\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwIndexOverflow() { throw ArithmeticException(\"Index overflow has happened.\") }\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwCountOverflow() { throw ArithmeticException(\"Count overflow has happened.\") }\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"PreconditionsKt\")\n\npackage kotlin\n\nimport kotlin.contracts.contract\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    require(value) { \"Failed requirement.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is null. Otherwise returns the not null value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return requireNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failRequireNotNullWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    } else {\n        return value\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    check(value) { \"Check failed.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return checkNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage]  if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    } else {\n        return value\n    }\n}\n\n\n/**\n * Throws an [IllegalStateException] with the given [message].\n *\n * @sample samples.misc.Preconditions.failWithError\n */\n@kotlin.internal.InlineOnly\npublic inline fun error(message: Any): Nothing = throw IllegalStateException(message.toString())\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"RangesKt\")\n\npackage kotlin.ranges\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\n\n/**\n * Returns a random element from this range.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun IntRange.random(): Int {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this range.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun LongRange.random(): Long {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this range.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun CharRange.random(): Char {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun IntRange.random(random: Random): Int {\n    try {\n        return random.nextInt(this)\n    } catch(e: IllegalArgumentException) {\n        throw NoSuchElementException(e.message)\n    }\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun LongRange.random(random: Random): Long {\n    try {\n        return random.nextLong(this)\n    } catch(e: IllegalArgumentException) {\n        throw NoSuchElementException(e.message)\n    }\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun CharRange.random(random: Random): Char {\n    try {\n        return random.nextInt(first.code, last.code + 1).toChar()\n    } catch(e: IllegalArgumentException) {\n        throw NoSuchElementException(e.message)\n    }\n}\n\n/**\n * Returns a random element from this range, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun IntRange.randomOrNull(): Int? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this range, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun LongRange.randomOrNull(): Long? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this range, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharRange.randomOrNull(): Char? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun IntRange.randomOrNull(random: Random): Int? {\n    if (isEmpty())\n        return null\n    return random.nextInt(this)\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun LongRange.randomOrNull(random: Random): Long? {\n    if (isEmpty())\n        return null\n    return random.nextLong(this)\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun CharRange.randomOrNull(random: Random): Char? {\n    if (isEmpty())\n        return null\n    return random.nextInt(first.code, last.code + 1).toChar()\n}\n\n/**\n * Returns `true` if this range contains the specified [element].\n * \n * Always returns `false` if the [element] is `null`.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline operator fun IntRange.contains(element: Int?): Boolean {\n    return element != null && contains(element)\n}\n\n/**\n * Returns `true` if this range contains the specified [element].\n * \n * Always returns `false` if the [element] is `null`.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline operator fun LongRange.contains(element: Long?): Boolean {\n    return element != null && contains(element)\n}\n\n/**\n * Returns `true` if this range contains the specified [element].\n * \n * Always returns `false` if the [element] is `null`.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline operator fun CharRange.contains(element: Char?): Boolean {\n    return element != null && contains(element)\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Byte): Boolean {\n    return contains(value.toInt())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Byte): Boolean {\n    return contains(value.toLong())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Byte): Boolean {\n    return contains(value.toShort())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Byte): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Byte): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Double): Boolean {\n    return value.toIntExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Double): Boolean {\n    return value.toLongExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Double): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Double): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Double): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Float): Boolean {\n    return value.toIntExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Float): Boolean {\n    return value.toLongExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Float): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Float): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Float): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Int): Boolean {\n    return contains(value.toLong())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Int): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Int): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Int): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Int): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Long): Boolean {\n    return value.toIntExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Long): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Long): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Long): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Long): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Short): Boolean {\n    return contains(value.toInt())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Short): Boolean {\n    return contains(value.toLong())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Short): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Short): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Short): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Int.downTo(to: Byte): IntProgression {\n    return IntProgression.fromClosedRange(this, to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Long.downTo(to: Byte): LongProgression {\n    return LongProgression.fromClosedRange(this, to.toLong(), -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Byte.downTo(to: Byte): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Short.downTo(to: Byte): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Char.downTo(to: Char): CharProgression {\n    return CharProgression.fromClosedRange(this, to, -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Int.downTo(to: Int): IntProgression {\n    return IntProgression.fromClosedRange(this, to, -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Long.downTo(to: Int): LongProgression {\n    return LongProgression.fromClosedRange(this, to.toLong(), -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Byte.downTo(to: Int): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to, -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Short.downTo(to: Int): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to, -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Int.downTo(to: Long): LongProgression {\n    return LongProgression.fromClosedRange(this.toLong(), to, -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Long.downTo(to: Long): LongProgression {\n    return LongProgression.fromClosedRange(this, to, -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Byte.downTo(to: Long): LongProgression {\n    return LongProgression.fromClosedRange(this.toLong(), to, -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Short.downTo(to: Long): LongProgression {\n    return LongProgression.fromClosedRange(this.toLong(), to, -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Int.downTo(to: Short): IntProgression {\n    return IntProgression.fromClosedRange(this, to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Long.downTo(to: Short): LongProgression {\n    return LongProgression.fromClosedRange(this, to.toLong(), -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Byte.downTo(to: Short): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Short.downTo(to: Short): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)\n}\n\n/**\n * Returns a progression that goes over the same range in the opposite direction with the same step.\n */\npublic fun IntProgression.reversed(): IntProgression {\n    return IntProgression.fromClosedRange(last, first, -step)\n}\n\n/**\n * Returns a progression that goes over the same range in the opposite direction with the same step.\n */\npublic fun LongProgression.reversed(): LongProgression {\n    return LongProgression.fromClosedRange(last, first, -step)\n}\n\n/**\n * Returns a progression that goes over the same range in the opposite direction with the same step.\n */\npublic fun CharProgression.reversed(): CharProgression {\n    return CharProgression.fromClosedRange(last, first, -step)\n}\n\n/**\n * Returns a progression that goes over the same range with the given step.\n */\npublic infix fun IntProgression.step(step: Int): IntProgression {\n    checkStepIsPositive(step > 0, step)\n    return IntProgression.fromClosedRange(first, last, if (this.step > 0) step else -step)\n}\n\n/**\n * Returns a progression that goes over the same range with the given step.\n */\npublic infix fun LongProgression.step(step: Long): LongProgression {\n    checkStepIsPositive(step > 0, step)\n    return LongProgression.fromClosedRange(first, last, if (this.step > 0) step else -step)\n}\n\n/**\n * Returns a progression that goes over the same range with the given step.\n */\npublic infix fun CharProgression.step(step: Int): CharProgression {\n    checkStepIsPositive(step > 0, step)\n    return CharProgression.fromClosedRange(first, last, if (this.step > 0) step else -step)\n}\n\ninternal fun Int.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toInt()..Byte.MAX_VALUE.toInt()) this.toByte() else null\n}\n\ninternal fun Long.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toLong()..Byte.MAX_VALUE.toLong()) this.toByte() else null\n}\n\ninternal fun Short.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toShort()..Byte.MAX_VALUE.toShort()) this.toByte() else null\n}\n\ninternal fun Double.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toDouble()..Byte.MAX_VALUE.toDouble()) this.toInt().toByte() else null\n}\n\ninternal fun Float.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toFloat()..Byte.MAX_VALUE.toFloat()) this.toInt().toByte() else null\n}\n\ninternal fun Long.toIntExactOrNull(): Int? {\n    return if (this in Int.MIN_VALUE.toLong()..Int.MAX_VALUE.toLong()) this.toInt() else null\n}\n\ninternal fun Double.toIntExactOrNull(): Int? {\n    return if (this in Int.MIN_VALUE.toDouble()..Int.MAX_VALUE.toDouble()) this.toInt() else null\n}\n\ninternal fun Float.toIntExactOrNull(): Int? {\n    return if (this in Int.MIN_VALUE.toFloat()..Int.MAX_VALUE.toFloat()) this.toInt() else null\n}\n\ninternal fun Double.toLongExactOrNull(): Long? {\n    return if (this in Long.MIN_VALUE.toDouble()..Long.MAX_VALUE.toDouble()) this.toLong() else null\n}\n\ninternal fun Float.toLongExactOrNull(): Long? {\n    return if (this in Long.MIN_VALUE.toFloat()..Long.MAX_VALUE.toFloat()) this.toLong() else null\n}\n\ninternal fun Int.toShortExactOrNull(): Short? {\n    return if (this in Short.MIN_VALUE.toInt()..Short.MAX_VALUE.toInt()) this.toShort() else null\n}\n\ninternal fun Long.toShortExactOrNull(): Short? {\n    return if (this in Short.MIN_VALUE.toLong()..Short.MAX_VALUE.toLong()) this.toShort() else null\n}\n\ninternal fun Double.toShortExactOrNull(): Short? {\n    return if (this in Short.MIN_VALUE.toDouble()..Short.MAX_VALUE.toDouble()) this.toInt().toShort() else null\n}\n\ninternal fun Float.toShortExactOrNull(): Short? {\n    return if (this in Short.MIN_VALUE.toFloat()..Short.MAX_VALUE.toFloat()) this.toInt().toShort() else null\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Int.until(to: Byte): IntRange {\n    return this .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Long.until(to: Byte): LongRange {\n    return this .. (to.toLong() - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Byte.until(to: Byte): IntRange {\n    return this.toInt() .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Short.until(to: Byte): IntRange {\n    return this.toInt() .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Char.until(to: Char): CharRange {\n    if (to <= '\\u0000') return CharRange.EMPTY\n    return this .. (to - 1).toChar()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Int.until(to: Int): IntRange {\n    if (to <= Int.MIN_VALUE) return IntRange.EMPTY\n    return this .. (to - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Long.until(to: Int): LongRange {\n    return this .. (to.toLong() - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Byte.until(to: Int): IntRange {\n    if (to <= Int.MIN_VALUE) return IntRange.EMPTY\n    return this.toInt() .. (to - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Short.until(to: Int): IntRange {\n    if (to <= Int.MIN_VALUE) return IntRange.EMPTY\n    return this.toInt() .. (to - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Int.until(to: Long): LongRange {\n    if (to <= Long.MIN_VALUE) return LongRange.EMPTY\n    return this.toLong() .. (to - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Long.until(to: Long): LongRange {\n    if (to <= Long.MIN_VALUE) return LongRange.EMPTY\n    return this .. (to - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Byte.until(to: Long): LongRange {\n    if (to <= Long.MIN_VALUE) return LongRange.EMPTY\n    return this.toLong() .. (to - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Short.until(to: Long): LongRange {\n    if (to <= Long.MIN_VALUE) return LongRange.EMPTY\n    return this.toLong() .. (to - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Int.until(to: Short): IntRange {\n    return this .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Long.until(to: Short): LongRange {\n    return this .. (to.toLong() - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Byte.until(to: Short): IntRange {\n    return this.toInt() .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Short.until(to: Short): IntRange {\n    return this.toInt() .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeastComparable\n */\npublic fun <T : Comparable<T>> T.coerceAtLeast(minimumValue: T): T {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Byte.coerceAtLeast(minimumValue: Byte): Byte {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Short.coerceAtLeast(minimumValue: Short): Short {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Int.coerceAtLeast(minimumValue: Int): Int {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Long.coerceAtLeast(minimumValue: Long): Long {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Float.coerceAtLeast(minimumValue: Float): Float {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Double.coerceAtLeast(minimumValue: Double): Double {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMostComparable\n */\npublic fun <T : Comparable<T>> T.coerceAtMost(maximumValue: T): T {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Byte.coerceAtMost(maximumValue: Byte): Byte {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Short.coerceAtMost(maximumValue: Short): Short {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Int.coerceAtMost(maximumValue: Int): Int {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Long.coerceAtMost(maximumValue: Long): Long {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Float.coerceAtMost(maximumValue: Float): Float {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Double.coerceAtMost(maximumValue: Double): Double {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceInComparable\n */\npublic fun <T : Comparable<T>> T.coerceIn(minimumValue: T?, maximumValue: T?): T {\n    if (minimumValue !== null && maximumValue !== null) {\n        if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n        if (this < minimumValue) return minimumValue\n        if (this > maximumValue) return maximumValue\n    }\n    else {\n        if (minimumValue !== null && this < minimumValue) return minimumValue\n        if (maximumValue !== null && this > maximumValue) return maximumValue\n    }\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Byte.coerceIn(minimumValue: Byte, maximumValue: Byte): Byte {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Short.coerceIn(minimumValue: Short, maximumValue: Short): Short {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Int.coerceIn(minimumValue: Int, maximumValue: Int): Int {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Long.coerceIn(minimumValue: Long, maximumValue: Long): Long {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Float.coerceIn(minimumValue: Float, maximumValue: Float): Float {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Double.coerceIn(minimumValue: Double, maximumValue: Double): Double {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified [range].\n * \n * @return this value if it's in the [range], or `range.start` if this value is less than `range.start`, or `range.endInclusive` if this value is greater than `range.endInclusive`.\n * \n * @sample samples.comparisons.ComparableOps.coerceInFloatingPointRange\n */\n@SinceKotlin(\"1.1\")\npublic fun <T : Comparable<T>> T.coerceIn(range: ClosedFloatingPointRange<T>): T {\n    if (range.isEmpty()) throw IllegalArgumentException(\"Cannot coerce value to an empty range: $range.\")\n    return when {\n        // this < start equiv to this <= start && !(this >= start)\n        range.lessThanOrEquals(this, range.start) && !range.lessThanOrEquals(range.start, this) -> range.start\n        // this > end equiv to this >= end && !(this <= end)\n        range.lessThanOrEquals(range.endInclusive, this) && !range.lessThanOrEquals(this, range.endInclusive) -> range.endInclusive\n        else -> this\n    }\n}\n\n/**\n * Ensures that this value lies in the specified [range].\n * \n * @return this value if it's in the [range], or `range.start` if this value is less than `range.start`, or `range.endInclusive` if this value is greater than `range.endInclusive`.\n * \n * @sample samples.comparisons.ComparableOps.coerceInComparable\n */\npublic fun <T : Comparable<T>> T.coerceIn(range: ClosedRange<T>): T {\n    if (range is ClosedFloatingPointRange) {\n        return this.coerceIn<T>(range)\n    }\n    if (range.isEmpty()) throw IllegalArgumentException(\"Cannot coerce value to an empty range: $range.\")\n    return when {\n        this < range.start -> range.start\n        this > range.endInclusive -> range.endInclusive\n        else -> this\n    }\n}\n\n/**\n * Ensures that this value lies in the specified [range].\n * \n * @return this value if it's in the [range], or `range.start` if this value is less than `range.start`, or `range.endInclusive` if this value is greater than `range.endInclusive`.\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Int.coerceIn(range: ClosedRange<Int>): Int {\n    if (range is ClosedFloatingPointRange) {\n        return this.coerceIn<Int>(range)\n    }\n    if (range.isEmpty()) throw IllegalArgumentException(\"Cannot coerce value to an empty range: $range.\")\n    return when {\n        this < range.start -> range.start\n        this > range.endInclusive -> range.endInclusive\n        else -> this\n    }\n}\n\n/**\n * Ensures that this value lies in the specified [range].\n * \n * @return this value if it's in the [range], or `range.start` if this value is less than `range.start`, or `range.endInclusive` if this value is greater than `range.endInclusive`.\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Long.coerceIn(range: ClosedRange<Long>): Long {\n    if (range is ClosedFloatingPointRange) {\n        return this.coerceIn<Long>(range)\n    }\n    if (range.isEmpty()) throw IllegalArgumentException(\"Cannot coerce value to an empty range: $range.\")\n    return when {\n        this < range.start -> range.start\n        this > range.endInclusive -> range.endInclusive\n        else -> this\n    }\n}\n\n",null],"names":[],"mappings":"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"}